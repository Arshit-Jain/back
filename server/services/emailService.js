import sgMail from '@sendgrid/mail'
import { GeminiService } from './gemini.js'
import PDFDocument from 'pdfkit'
import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

// Configure SendGrid
sgMail.setApiKey(process.env.SENDGRID_API_KEY)

/**
 * Generate a summary of the research report
 */
const generateSummary = (researchContent) => {
  // Extract key sections and create a concise summary
  const lines = researchContent.split('\n')
  const summary = []
  
  // Find main headings and key points
  let currentSection = ''
  let keyPoints = []
  
  for (const line of lines) {
    const trimmedLine = line.trim()
    
    // Capture main headings
    if (trimmedLine.startsWith('# ')) {
      if (currentSection && keyPoints.length > 0) {
        summary.push(`**${currentSection}**: ${keyPoints.slice(0, 3).join('; ')}`)
      }
      currentSection = trimmedLine.substring(2)
      keyPoints = []
    }
    // Capture subheadings and key points
    else if (trimmedLine.startsWith('## ') || trimmedLine.startsWith('### ')) {
      if (trimmedLine.length > 0) {
        keyPoints.push(trimmedLine.substring(trimmedLine.indexOf(' ') + 1))
      }
    }
    // Capture bullet points
    else if (trimmedLine.startsWith('- ') || trimmedLine.startsWith('* ')) {
      if (trimmedLine.length > 0) {
        keyPoints.push(trimmedLine.substring(2))
      }
    }
  }
  
  // Add the last section
  if (currentSection && keyPoints.length > 0) {
    summary.push(`**${currentSection}**: ${keyPoints.slice(0, 3).join('; ')}`)
  }
  
  return summary.join('\n\n')
}

/**
 * Generate PDF from research content
 */
const generatePDF = (researchContent, topic) => {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({
        size: 'A4',
        margins: {
          top: 50,
          bottom: 50,
          left: 50,
          right: 50
        }
      })
      
      // Create a temporary file path
      const tempDir = path.join(__dirname, '../temp')
      if (!fs.existsSync(tempDir)) {
        fs.mkdirSync(tempDir, { recursive: true })
      }
      
      const fileName = `research-report-${Date.now()}.pdf`
      const filePath = path.join(tempDir, fileName)
      
      // Pipe the PDF to a file
      const stream = fs.createWriteStream(filePath)
      doc.pipe(stream)
      
      // Add title
      doc.fontSize(24)
        .font('Helvetica-Bold')
        .text('OpenAI Deep Research Results', { align: 'center' })
      
      doc.moveDown(1)
      
      // Add topic
      doc.fontSize(18)
        .font('Helvetica')
        .text(`Research Topic: ${topic}`, { align: 'center' })
      
      doc.moveDown(2)
      
      // Add content
      doc.fontSize(12)
        .font('Helvetica')
      
      // Process the content line by line
      const lines = researchContent.split('\n')
      let isInList = false
      
      for (const line of lines) {
        const trimmedLine = line.trim()
        
        if (trimmedLine === '') {
          doc.moveDown(0.5)
          isInList = false
          continue
        }
        
        // Handle headings
        if (trimmedLine.startsWith('# ')) {
          doc.fontSize(18)
            .font('Helvetica-Bold')
            .text(trimmedLine.substring(2))
            .moveDown(0.5)
        } else if (trimmedLine.startsWith('## ')) {
          doc.fontSize(16)
            .font('Helvetica-Bold')
            .text(trimmedLine.substring(3))
            .moveDown(0.3)
        } else if (trimmedLine.startsWith('### ')) {
          doc.fontSize(14)
            .font('Helvetica-Bold')
            .text(trimmedLine.substring(4))
            .moveDown(0.2)
        }
        // Handle bullet points
        else if (trimmedLine.startsWith('- ') || trimmedLine.startsWith('* ')) {
          if (!isInList) {
            doc.moveDown(0.3)
            isInList = true
          }
          doc.fontSize(12)
            .font('Helvetica')
            .text(`• ${trimmedLine.substring(2)}`, { indent: 20 })
        }
        // Handle regular text
        else {
          doc.fontSize(12)
            .font('Helvetica')
            .text(trimmedLine)
          isInList = false
        }
      }
      
      // Add footer
      doc.moveDown(2)
      doc.fontSize(10)
        .font('Helvetica')
        .text('Generated by OpenAI Deep Research System', { align: 'center' })
      doc.text(new Date().toLocaleDateString(), { align: 'center' })
      
      // Finalize the PDF
      doc.end()
      
      stream.on('finish', () => {
        resolve({ filePath, fileName })
      })
      
      stream.on('error', (error) => {
        reject(error)
      })
      
    } catch (error) {
      reject(error)
    }
  })
}

/**
 * Generate a short paragraph summary from combined markdown
 */
const generateSummaryParagraph = (combinedMarkdown) => {
  const text = combinedMarkdown
    .replace(/[#*_`>-]/g, '')
    .replace(/\n+/g, ' ')
    .trim()
  return text.length > 650 ? text.slice(0, 640) + '…' : text
}

/**
 * Generate a combined PDF with ChatGPT and Gemini sections
 */
const generateCombinedPDF = (chatgptContent, geminiContent, topic) => {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({ size: 'A4', margins: { top: 50, bottom: 50, left: 50, right: 50 } })
      const tempDir = path.join(__dirname, '../temp')
      if (!fs.existsSync(tempDir)) fs.mkdirSync(tempDir, { recursive: true })
      const fileName = `research-combined-${Date.now()}.pdf`
      const filePath = path.join(tempDir, fileName)

      const stream = fs.createWriteStream(filePath)
      doc.pipe(stream)

      doc.fontSize(22).font('Helvetica-Bold').text('Combined Research Results', { align: 'center' })
      doc.moveDown(0.5)
      doc.fontSize(16).font('Helvetica').text(`Topic: ${topic}`, { align: 'center' })
      doc.moveDown(1)

      const writeMarkdown = (label, content) => {
        doc.addPage()
        doc.fontSize(18).font('Helvetica-Bold').text(label, { align: 'left' })
        doc.moveDown(0.5)
        const lines = String(content || '').split('\n')
        let inList = false
        for (const raw of lines) {
          const line = raw.trim()
          if (!line) { doc.moveDown(0.4); inList = false; continue }
          if (line.startsWith('# ')) { doc.fontSize(16).font('Helvetica-Bold').text(line.slice(2)).moveDown(0.3); continue }
          if (line.startsWith('## ')) { doc.fontSize(14).font('Helvetica-Bold').text(line.slice(3)).moveDown(0.2); continue }
          if (line.startsWith('### ')) { doc.fontSize(13).font('Helvetica-Bold').text(line.slice(4)).moveDown(0.2); continue }
          if (line.startsWith('- ') || line.startsWith('* ')) {
            if (!inList) { doc.moveDown(0.2); inList = true }
            doc.fontSize(11).font('Helvetica').text(`• ${line.slice(2)}`, { indent: 20 })
            continue
          }
          doc.fontSize(11).font('Helvetica').text(line)
          inList = false
        }
      }

      writeMarkdown('ChatGPT (OpenAI) Research', chatgptContent)
      writeMarkdown('Gemini (Google) Research', geminiContent)

      doc.end()
      stream.on('finish', () => resolve({ filePath, fileName }))
      stream.on('error', reject)
    } catch (e) { reject(e) }
  })
}

/**
 * Send research report via email
 */
export const sendResearchReport = async (userEmail, researchContent, topic) => {
  let filePath = null
  
  try {
    console.log('=== Email Service: Starting email generation ===', { userEmail, topic })
    
    // Validate SendGrid configuration
    if (!process.env.SENDGRID_API_KEY) {
      throw new Error('SendGrid API key not configured. Please set SENDGRID_API_KEY in your environment variables.')
    }
    
    if (!process.env.FROM_EMAIL) {
      throw new Error('From email not configured. Please set FROM_EMAIL in your environment variables.')
    }
    
    // Generate summary
    const summary = generateSummary(researchContent)
    console.log('=== Email Service: Summary generated ===', { summaryLength: summary.length })
    
    // Generate PDF
    const pdfResult = await generatePDF(researchContent, topic)
    filePath = pdfResult.filePath
    const fileName = pdfResult.fileName
    console.log('=== Email Service: PDF generated ===', { fileName })
    
    // Read PDF file
    const pdfBuffer = fs.readFileSync(filePath)
    
    // Prepare email content
    const emailContent = {
      to: userEmail,
      from: process.env.FROM_EMAIL,
      subject: `OpenAI Deep Research Results: ${topic}`,
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #333; text-align: center;">OpenAI Deep Research Results</h2>
          
          <div style="background-color: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3 style="color: #495057; margin-top: 0;">Research Topic</h3>
            <p style="font-size: 16px; color: #212529;">${topic}</p>
          </div>
          
          <div style="background-color: #e3f2fd; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3 style="color: #1976d2; margin-top: 0;">Executive Summary</h3>
            <div style="white-space: pre-line; line-height: 1.6; color: #424242;">
              ${summary}
            </div>
          </div>
          
          <div style="background-color: #f1f8e9; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3 style="color: #388e3c; margin-top: 0;">Complete Report</h3>
            <p style="color: #424242;">
              Please find the complete research report attached as a PDF document. 
              The report contains detailed analysis, findings, and recommendations based on your research topic.
            </p>
          </div>
          
          <div style="text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #dee2e6;">
            <p style="color: #6c757d; font-size: 14px;">
              This report was generated by the OpenAI Deep Research System.<br>
              Generated on ${new Date().toLocaleDateString()}
            </p>
          </div>
        </div>
      `,
      text: `
        OpenAI Deep Research Results
        
        Research Topic: ${topic}
        
        Executive Summary:
        ${summary}
        
        Complete Report:
        Please find the complete research report attached as a PDF document.
        
        Generated by OpenAI Deep Research System
        ${new Date().toLocaleDateString()}
      `,
      attachments: [
        {
          content: pdfBuffer.toString('base64'),
          filename: fileName,
          type: 'application/pdf',
          disposition: 'attachment'
        }
      ]
    }
    
    // Send email
    console.log('=== Email Service: Sending email ===')
    const result = await sgMail.send(emailContent)
    console.log('=== Email Service: Email sent successfully ===', { messageId: result[0].headers['x-message-id'] })
    
    // Clean up temporary file
    fs.unlinkSync(filePath)
    console.log('=== Email Service: Temporary file cleaned up ===')
    
    return {
      success: true,
      messageId: result[0].headers['x-message-id'],
      summary
    }
    
  } catch (error) {
    console.error('=== Email Service: Error sending email ===', error)
    
    // Clean up temporary file if it exists
    try {
      if (filePath && fs.existsSync(filePath)) {
        fs.unlinkSync(filePath)
      }
    } catch (cleanupError) {
      console.error('Error cleaning up temporary file:', cleanupError)
    }
    
    throw new Error(`Failed to send research report: ${error.message}`)
  }
}

/**
 * Send a combined ChatGPT+Gemini report via SendGrid with brief summary in body
 */
export const sendCombinedResearchReportSendGrid = async (userEmail, chatgptContent, geminiContent, topic) => {
  let filePath = null
  try {
    console.log('=== Email Service: Starting combined email generation ===', { userEmail, topic })

    if (!process.env.SENDGRID_API_KEY) {
      throw new Error('SendGrid API key not configured. Please set SENDGRID_API_KEY.')
    }
    if (!process.env.FROM_EMAIL) {
      throw new Error('From email not configured. Please set FROM_EMAIL.')
    }

    const combinedMarkdown = `## ChatGPT (OpenAI)\n\n${chatgptContent}\n\n---\n\n## Gemini (Google)\n\n${geminiContent}`
    let summaryParagraph = ''
    // Prefer Gemini summary per request; fallback to local summarizer
    try {
      const sum = await GeminiService.summarizeCombinedReport(combinedMarkdown)
      if (sum.success && sum.summary) {
        summaryParagraph = sum.summary
      } else {
        summaryParagraph = generateSummaryParagraph(combinedMarkdown)
      }
    } catch (e) {
      summaryParagraph = generateSummaryParagraph(combinedMarkdown)
    }

    const pdf = await generateCombinedPDF(chatgptContent, geminiContent, topic)
    filePath = pdf.filePath
    const pdfBuffer = fs.readFileSync(filePath)

    const emailContent = {
      to: userEmail,
      from: process.env.FROM_EMAIL,
      subject: `Combined Research Results: ${topic}`,
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 700px; margin: 0 auto;">
          <h2 style="margin:0 0 10px;">Combined Research Results</h2>
          <div style="color:#333; white-space:pre-wrap;">${summaryParagraph}</div>
          <hr style="border:none;border-top:1px solid #eee;margin:20px 0;"/>
          <h3 style="margin:10px 0;">ChatGPT (OpenAI) Research</h3>
          <pre style="white-space:pre-wrap; background:#fafafa; padding:12px; border-radius:6px;">${chatgptContent}</pre>
          <h3 style="margin:10px 0;">Gemini (Google) Research</h3>
          <pre style="white-space:pre-wrap; background:#fafafa; padding:12px; border-radius:6px;">${geminiContent}</pre>
          <p style="color:#666; font-size:12px;">Full combined PDF attached.</p>
        </div>
      `,
      text: `Combined Research Results\n\n${summaryParagraph}\n\n[ChatGPT (OpenAI) Research]\n${chatgptContent}\n\n[Gemini (Google) Research]\n${geminiContent}`,
      attachments: [
        {
          content: pdfBuffer.toString('base64'),
          filename: pdf.fileName,
          type: 'application/pdf',
          disposition: 'attachment'
        }
      ]
    }

    console.log('=== Email Service: Sending combined email via SendGrid ===')
    const result = await sgMail.send(emailContent)
    console.log('=== Email Service: Combined email sent ===', { messageId: result[0].headers['x-message-id'] })

    if (filePath && fs.existsSync(filePath)) fs.unlinkSync(filePath)

    return { success: true, messageId: result[0].headers['x-message-id'], summary: summaryParagraph }
  } catch (error) {
    console.error('=== Email Service: Error sending combined email ===', error)
    try { if (filePath && fs.existsSync(filePath)) fs.unlinkSync(filePath) } catch {}
    throw new Error(`Failed to send combined research report: ${error.message}`)
  }
}

export default {
  sendResearchReport,
  sendCombinedResearchReportSendGrid
}
